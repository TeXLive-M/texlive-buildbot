# -*- python -*-
# vim: ft=python:ts=4

import json
import os

#from buildbot.buildslave import BuildSlave
from buildbot.plugins import buildslave, changes, schedulers, status, steps, util
from buildbot.changes import gitpoller, svnpoller
#from buildbot.status.web.baseweb import WebStatus
from buildbot.status.html import WebStatus


####### HELPER FUNCTIONS #######

def _path(name):
    return os.path.join(os.path.dirname(__file__), name)


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

config = {
    'slavesconfig' : _path('slaves.json'),
    'htpasswdfile' : _path('htpasswd'),

    'slaveport'    : 9989,
    'httpport'     : 8010,

    'title'        : 'ConTeXt Build farm',
    'titleURL'     : 'http://build.contextgarden.net',
    'downloadURL'  : 'http://dl.contextgarden.net/build',
    'db_url'       : 'sqlite:///state.sqlite',
}


####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.

with open(config['slavesconfig']) as f:
    slavedata = json.load(f)

# list of build slaves
c['slaves'] = [buildslave.BuildSlave(name, pwd) for name, pwd in slavedata['slaves'].iteritems()]

# list of all builders on all slaves (including cross-compilers)
build_platforms = []
for slave in slavedata['build_platforms']:
    for arch in slave['archs']:
        build_platforms.append({'platform' : slave['platform'], 'arch' : arch, 'code' : slave['code'], 'slave' : slave['slave']})

# 'protocols' contains information about protocols which master will use for
# communicating with slaves.
# You must define at least 'port' option that slaves could connect to your master
# with this protocol.
# 'port' must match the value configured into the buildslaves (with their
# --master option)
c['protocols'] = {'pb': {'port': config['slaveport']}}


####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot clone of pyflakes.


# TODO: also watch the experimental branch
c['change_source'] = []
c['change_source'].append(svnpoller.SVNPoller(
    svnurl='svn://tug.org/texlive/trunk/Build/source',
    category='texlive',
    project='texlive'))
#c['change_source'].append(svnpoller.SVNPoller(
#    svnurl='https://foundry.supelec.fr/svn/luatex/trunk',
#    category='luatex', # or luatex?
#    project='luatex'))
#c['change_source'].append(gitpoller.GitPoller(
#    repourl='git://git.code.sf.net/p/xetex/code',
#    category='xetex', # or xetex?
#    project='xetex',
#    #workdir='gitpoller-workdir',
#    #branch='master',
#    branches=['master'],
#    pollinterval=300))


####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.changes import filter
from buildbot.plugins import schedulers

build_components = ['texlive', 'xz', 'wget']
builders = {}
builders_all = []
for component in build_components:
    builders[component] = ['{}.{}-{}.{}'.format(component, plat['platform'], plat['arch'], plat['code']) for plat in build_platforms]
    builders_all += builders[component]

c['schedulers'] = [
    schedulers.ForceScheduler(
        name='force-build', # anything; use your own convension, doesn't have to match anything else
        builderNames=builders_all),
    schedulers.Nightly(
        name='texlive-nightly',
        branch=None,
        change_filter=filter.ChangeFilter(project='texlive'),
        builderNames=builders['texlive'],
        hour=20, # run each day at 20:00
        onlyIfChanged=True),
#    SingleBranchScheduler(
#        name="luatex",
#        change_filter=filter.ChangeFilter(project='luatex'),
#        treeStableTimer=None,
#        builderNames=builders['luatex']),
#    SingleBranchScheduler(
#        name="xetex",
#        change_filter=filter.ChangeFilter(branch=None),
#        treeStableTimer=None,
#        builderNames=buiders['xtex']),
    ]


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.source.svn import SVN
from buildbot.steps.shell import ShellCommand
from buildbot.plugins import steps
#from buildbot.plugins.steps import MakeDirectory
from buildbot.steps.shell import Configure
from buildbot.steps.shell import Compile
from buildbot.steps.shell import Test


build_sources = {
    'xz'   : { 'version' : '5.2.3',   'suffix' : '.tar.gz', 'url': 'http://tukaani.org/xz' },
    'wget' : { 'version' : '1.19.1',  'suffix' : '.tar.gz', 'url': 'http://gnu.mirror.si/wget' },
}
for s in build_sources:
    d = build_sources[s]
    name      = "{}-{}".format(s, d['version'])
    filename  = "{}{}".format(name, d['suffix'])
    signature = "{}.sig".format(filename)
    build_sources[s]['name'] = name
    build_sources[s]['file'] = filename
    build_sources[s]['sig']  = signature
    build_sources[s]['file_url'] = "{}/{}".format(d['url'], filename)
    build_sources[s]['sig_url']  = "{}/{}".format(d['url'], signature)

# for xz, wget, ...
class SimpleToolFactory(BuildFactory):

    def __init__(self, name, platform, buildSource,
                 configureEnv={},
                 configureFlags=[],
                 builddir="build",
                 stripCommand=None,
                 filesToUpload=[],
                ):
        BuildFactory.__init__(self)

        # this is where the sources are
        basedir = "build"
        # this is where we build the binaries
        workdir = os.path.join(basedir, "build")

        extractCommand = ['tar']
        buildCommand   = ['make']

        if platform['platform'] == 'solaris':
            extractCommand = ['gtar']
            buildCommand = ['gmake']
        elif platform['platform'] == 'darwin':

            target = '10.5'
            if platform['arch'] == 'x86_64':
                target =  '10.6'
            libdir  = '-L/Developer/SDKs/MacOSX{}.sdk/usr/lib'.format(target)
            sysroot = '-isysroot /Developer/SDKs/MacOSX{}.sdk -mmacosx-version-min={}'.format(target, target)

            if platform['arch'] == 'powerpc':
                configureEnv['CC']  = '/usr/bin/gcc-4.2 -arch ppc'
                configureEnv['CXX'] = '/usr/bin/g++-4.2 -arch ppc'
            else:
                #configureEnv['CC']  = 'clang-mp-3.7 -arch {}'.format(platform['arch'])
                #configureEnv['CXX'] = 'clang++-mp-3.7 -arch {}'.format(platform['arch'])
                configureEnv['CC']  = '/usr/bin/gcc-4.2 -arch {}'.format(platform['arch'])
                configureEnv['CXX'] = '/usr/bin/g++-4.2 -arch {}'.format(platform['arch'])

            #configureEnv['OBJC']   = texlive_build_env['CC']
            #configureEnv['OBJCXX'] = texlive_build_env['CXX']

            for flags in ['CFLAGS', 'OBJCFLAGS', 'CXXFLAGS', 'OBJCXXFLAGS']:
                configureEnv[flags] = sysroot
            configureEnv['LDFLAGS'] = libdir + ' ' + sysroot


        checkCommand = buildCommand + ['check']

        if buildSource['suffix'] == '.tar.gz':
            extractCommand.append('xvzf')
        elif buildSource['suffix'] == '.tar.bz2':
            extractCommand.append('xvjf')
        elif buildSource['suffix'] == '.tar.bz2':
            extractCommand.append('xvJf')
        extractCommand.append(buildSource['file'])

        configureCommand = [os.path.join("..", buildSource['name'], "configure")]

        # TODO: this should be a single cleanup step: remove sources + build directory, only leave the downloaded file
        # CLEANUP (TODO)
        #self.addStep(steps.RemoveDirectory(dir=workdir))
        #self.addStep(steps.MakeDirectory(dir=workdir))

        # DOWNLOAD
        self.addStep(ShellCommand(
                name="download",
                command=["wget", "-N", "-c", buildSource['file_url']],
                description="fetch sources",
                descriptionDone="fetched sources of {}".format(buildSource['name'])))
        # EXTRACT
        self.addStep(ShellCommand(
                name="extract",
                command=extractCommand,
                description="extract sources",
                descriptionDone="extracted sources"))
        # CONFIGURE
        self.addStep(Configure(
                command=configureCommand + configureFlags,
                env=configureEnv,
                logfiles={'config.log': 'config.log'},
                workdir=workdir))
        # BUILD
        self.addStep(Compile(
                command=buildCommand,
                env=configureEnv,
                workdir=workdir))
        # TEST
        self.addStep(ShellCommand(
                name='test',
                command=checkCommand,
                env=configureEnv,
                logfiles={'test-suite.log': 'tests/test-suite.log'},
                workdir=workdir,
                description='test',
                descriptionDone='tested'))
        # STRIP
        if stripCommand != None:
            self.addStep(ShellCommand(
                    name="strip",
                    command=stripCommand,
                    env=configureEnv,
                    workdir=workdir,
                    description="strip binaries",
                    descriptionDone="stripped binaries"))
        # UPLOAD
        for f in filesToUpload:
            fileSrc  = os.path.join(builddir, f['srcpath'], f['srcfile'])
            fileDest = os.path.join(f['destpath'], f['destfile'])
            self.addStep(steps.FileUpload(
                slavesrc=fileSrc,
                masterdest=os.path.join('/context/www/contextgarden.net/dl/build', fileDest),
                keepstamp=True,
                mode=0644, # TODO?
                url='{}/{}'.format(config['downloadURL'], fileDest),
                name='upload_{}'.format(f['srcfile']),
                description='upload {}'.format(f['destfile']),
                descriptionDone='uploaded {}'.format(f['destfile']),
            ))

def m_factory_xz(platform):
    configureFlags = [
        "--disable-nls",
        "--disable-shared"
    ]
    configureEnv = {}
    ## TODO: these variables should be defined somewhere else, more globally
    if platform['platform'] == 'solaris':
        configureEnv['CC'] = '/opt/csw/bin/gcc-5.2'
        configureEnv['CXX'] = '/opt/csw/bin/g++-5.2'
        configureEnv['PATH'] = [ '${PATH}', '/usr/ccs/bin']
        configureEnv['GREP'] = 'ggrep'

    stripCommand  = ["strip", "src/xz/xz", "src/xzdec/xzdec"]

    filesToUpload = [
        { 'srcpath': 'src/xz',    'srcfile': 'xz',    'destpath': 'xz', 'destfile': 'xz.{}-{}'.format(platform['arch'], platform['platform']) },
        { 'srcpath': 'src/xzdec', 'srcfile': 'xzdec', 'destpath': 'xz', 'destfile': 'xzdec.{}-{}'.format(platform['arch'], platform['platform']) },
    ]

    return SimpleToolFactory(
        name = 'xz',
        platform = platform,
        buildSource = build_sources['xz'],
        configureEnv = configureEnv,
        configureFlags = configureFlags,
        stripCommand = stripCommand,
        filesToUpload = filesToUpload,
    )

def m_factory_wget(platform):
    configureFlags = [
        '--enable-ipv6',
        '--disable-iri',
        '--disable-nls',
        '--disable-ntlm',
        '--disable-pcre',
        '--without-libiconv-prefix',
        '--without-libintl-prefix',
        '--without-libuuid',
        '--without-libpsl',
        '--without-ssl',
        '--without-zlib',
    ]
    configureEnv = {}
    ## TODO: these variables should be defined somewhere else, more globally
    if platform['platform'] == 'solaris':
        configureEnv['CC'] = '/opt/csw/bin/gcc-5.2'
        configureEnv['CXX'] = '/opt/csw/bin/g++-5.2'
        configureEnv['PATH'] = [ '${PATH}', '/usr/ccs/bin']

    stripCommand = ['strip', 'src/wget']

    filesToUpload = [
        { 'srcpath': 'src', 'srcfile': 'wget', 'destpath': 'wget', 'destfile': 'wget.{}-{}'.format(platform['arch'], platform['platform']) },
    ]

    return SimpleToolFactory(
        name = 'wget',
        platform = platform,
        buildSource = build_sources['wget'],
        configureEnv = configureEnv,
        configureFlags = configureFlags,
        stripCommand = stripCommand,
        filesToUpload = filesToUpload,
    )

class TeXLiveFactory(BuildFactory):

    def __init__(self, source, name, configure="../source/configure",
                 configureEnv={},
                 configureFlags=[],
                 reconf=None,
                 platform=None,
                 builddir=None,
                 make="make",
                 compile_targets=[[]],
                 files=[],
                 strip=True
                 # compile=["make", "all"],
                 # test=["make", "check"],
                 # distcheck=["make", "distcheck"]
                 ):
        BuildFactory.__init__(self, [source])

        # determine the build dir
        if builddir is None:
            if platform is None:
                builddir = "build"
            else:
                builddir = "build-" + platform

        configureEnvLocal = {}
        configureFlagsLocal = []
        # whether to use make or gmake (TODO: this could be set outside as well)
        if 'solaris' in platform:
            make = "gmake"
            configureEnvLocal['MAKE'] = "gmake"
            # just for luatex & texlive, just for solaris
            configureEnvLocal['LIBPNG_USER_CPPFLAGS'] = '"-D_XOPEN_SOURCE=600"'
        configureEnvLocal['myplatform'] = platform

        self.addStep(steps.RemoveDirectory(dir=os.path.join("build", builddir)))
        self.addStep(steps.MakeDirectory(dir=os.path.join("build", builddir)))

        if reconf is True:
            reconf = ["autoreconf", "-si"]
        if reconf is not None:
            self.addStep(ShellCommand(
                name="autoreconf",
                command=reconf,
                description="running autotools",
                descriptionDone="autoreconfigured"))
            # TODO: is tihs a bug somewhere in autoconf?
            if 'solaris' in platform or 'darwin' in platform:
                configureFlagsLocal = ['--disable-dependency-tracking']

        if configure is not None:
            # we either need to wind up with a string (which will be
            # space-split), or with a list of strings (which will not). The
            # list of strings is the preferred form.
            if isinstance(configure, str):
                if configureFlags:
                    assert " " not in configure  # please use list instead
                    command = [configure] + configureFlags + configureFlagsLocal
                else:
                    command = configure
            else:
                assert isinstance(configure, (list, tuple))
                command = configure + configureFlags
            self.addStep(Configure(command=command,
                env=configureEnvLocal,
                workdir="build/{}".format(builddir)))
        if compile_targets is not None:
            command = []
            for target in compile_targets:
                command = command + [make] + target + ["&&"]
                #command = [make] + target
                #print("hello {}".format(len(target)))
                #command = [make] + target
                #self.addStep(Compile(command=command, workdir="build/{}".format(builddir)))
            #command = " ".join(command[:-1])
            self.addStep(Compile(
                command=" ".join(command[:-1]),
                env=configureEnvLocal,
                workdir=os.path.join("build", builddir)))
        #self.addStep(Test(command=[make, "test"]))
        #if test is not None:
        #    self.addStep(Test(command=test))
        #if distcheck is not None:
        #    self.addStep(Test(command=distcheck))
        for ff in files:
            fpath = ff[0]
            fname = ff[1]
            file_master = os.path.join(builddir, fpath, fname)
            file_slave  = os.path.join("build", name, platform, fname)
            if strip is True:
                self.addStep(ShellCommand(
                    name="strip {}".format(fname),
                    description="strip {}".format(fname),
                    command=["strip", file_master]))
            # TODO: MultipleFileUpload
            # TODO: wrong permissions
            self.addStep(steps.FileUpload(
                slavesrc=file_master,
                masterdest="/context/www/contextgarden.net/dl/{}".format(file_slave),
                keepstamp=True,
                mode=0644,
                url="http://dl.contextgarden.net/{}".format(file_slave),
                name="upload {}".format(fname),
                description="upload {}".format(fname)))

def make_factory_texlive(platform):
    needs_proxy = (platform['platform'] == 'solaris')
    # TODO:
    texlive_url='svn{}://tug.org/texlive/trunk/Build/source'.format('+proxy' if needs_proxy else '')

    factory_texlive = BuildFactory()
    texlive_build_env={}
    #factory_texlive.addStep(SVN(repourl='svn+proxy://tug.org/texlive/trunk/Build/source'))
    if platform['platform'] == 'solaris' or 'bsd' in platform['platform']:
        texlive_build_env['TL_MAKE'] = 'gmake'

    if platform['platform'] == 'solaris':
        texlive_build_command=['./Build', '--without-iconv']
        #texlive_build_env={'LIBPNG_USER_CPPFLAGS': '-D_XOPEN_SOURCE=600', 'TL_MAKE': 'gmake'}
        texlive_build_env['TL_MAKE'] = 'gmake'
        texlive_build_env['PATH']    = [ '${PATH}', '/usr/ccs/bin']
        if platform['arch'] == 'x86_64':
             texlive_build_env['CC']  = '/opt/csw/bin/gcc-5.2 -m64'
             texlive_build_env['CXX'] = '/opt/csw/bin/g++-5.2 -m64'
        else:
             texlive_build_env['CC']  = '/opt/csw/bin/gcc-5.2'
             texlive_build_env['CXX'] = '/opt/csw/bin/g++-5.2'
    elif platform['platform'] == 'darwin' :
        texlive_build_command = ['./Build', '--disable-dvisvgm']

        target = '10.5'
        if platform['arch'] == 'x86_64':
            target =  '10.6'
        libdir  = '-L/Developer/SDKs/MacOSX{}.sdk/usr/lib'.format(target)
        sysroot = '-isysroot /Developer/SDKs/MacOSX{}.sdk -mmacosx-version-min={}'.format(target, target)

        if platform['arch'] == 'powerpc':
            texlive_build_env['CC']  = '/usr/bin/gcc-4.2 -arch ppc'
            texlive_build_env['CXX'] = '/usr/bin/g++-4.2 -arch ppc'
            texlive_build_command.extend(['--disable-luajittex', '--disable-mfluajit'])
        else:
            texlive_build_env['CC']  = 'clang-mp-3.7 -arch {}'.format(platform['arch'])
            texlive_build_env['CXX'] = 'clang++-mp-3.7 -arch {}'.format(platform['arch'])

        texlive_build_env['OBJC']   = texlive_build_env['CC']
        texlive_build_env['OBJCXX'] = texlive_build_env['CXX']

        for flags in ['CFLAGS', 'OBJCFLAGS', 'CXXFLAGS', 'OBJCXXFLAGS']:
            texlive_build_env[flags] = sysroot
        texlive_build_env['LDFLAGS'] = libdir + ' ' + sysroot

    else:
        texlive_build_command=['./Build']

    # check out the source
    factory_texlive.addStep(SVN(repourl=texlive_url,method='copy'))
    # build it
    factory_texlive.addStep(ShellCommand(
        command=texlive_build_command,
        env=texlive_build_env,
        description='building',
        descriptionDone='build'))
    # TODO: add uploader
    # cleanup svn sources in case of an earlier error (this step should do more cleanup)
    factory_texlive.addStep(ShellCommand(
        name='cleanup',
        command=['svn', 'cleanup'],
        alwaysRun=True))
    return factory_texlive

def m_factory_luatex(plat):
    return TeXLiveFactory(
    source = SVN(
        repourl='https://foundry.supelec.fr/svn/luatex/trunk',
        username='anonsvn',
        extra_args=['--password','anonsvn'],
        method='copy'),
    name = 'luatex',
    platform = platform_map[plat],
    configure = "../source/configure",
    configureFlags = [
        "--enable-cxx-runtime-hack",
        "--disable-all-pkgs",
        "--disable-shared",
        "--disable-ptex",
        "--disable-ipc",
        "--enable-largefile",
        "--enable-silent-rules",
        "--enable-dump-share",
        "--enable-mp",
        "--enable-luatex",
        "--without-system-ptexenc",
        "--without-system-kpathsea",
        "--without-system-poppler",
        "--without-system-xpdf",
        "--without-system-freetype",
        "--without-system-freetype2",
        "--without-system-gd",
        "--without-system-libpng",
        "--without-system-teckit",
        "--without-system-zlib",
        "--without-system-t1lib",
        "--without-system-icu",
        "--without-system-graphite",
        "--without-system-zziplib",
        "--without-mf-x-toolkit",
        "--without-x"
    ],
    compile_targets = [
        [],
        ["-C", "libs", "all"],
        ["-C", "libs/zziplib", "all"],
        ["-C", "libs/zlib", "all"],
        ["-C", "libs/libpng", "all"],
        ["-C", "libs/poppler", "all"],
        ["-C", "texk", "web2c/Makefile"],
        ["-C", "texk/kpathsea"],
        ["-C", "texk/web2c", "luatex"]],
    files = [["texk/web2c", "luatex"]],
    strip = True
)

def m_factory_xetex(platform):
    return TeXLiveFactory(
    source = Git(
        repourl = 'git://git.code.sf.net/p/xetex/code',
        mode = 'incremental'),
    name      = 'xetex',
    platform  = platform_map[plat],
    reconf    = ["./source/autogen.sh"],
    configure = "../source/configure",
    configureFlags = [
        "--enable-cxx-runtime-hack",
        "--disable-all-pkgs",
        "--disable-shared",
        "--disable-ptex",
        "--enable-largefile",
        "--enable-silent-rules",
        "--enable-xetex",
        "--without-system-ptexenc",
        "--without-system-kpathsea",
        "--without-system-poppler",
        "--without-system-freetype2",
        "--without-system-libpng",
        "--without-system-teckit",
        "--without-system-zlib",
        "--without-system-icu",
        "--without-system-graphite2",
        "--without-system-harfbuzz",
        "--without-mf-x-toolkit",
        "--without-x",
    ],
    compile_targets = [[], ["-C", "texk/web2c", "xetex"]],
    files = [["texk/web2c", "xetex"]],
    strip = True
)

from buildbot.config import BuilderConfig

c['builders'] = []

for plat in build_platforms:
    tags = ['os/{}'.format(plat['platform'])] # ['pl/{}-{}'.format(plat['platform'], plat['arch'])]
    c['builders'].append(
        BuilderConfig(name = 'xz.{}-{}.{}'.format(plat['platform'], plat['arch'], plat['code']),
            slavenames = [plat['slave']],
            mergeRequests = True,
            factory = m_factory_xz(plat),
            tags = ['c/xz'] + tags))
    c['builders'].append(
        BuilderConfig(name = 'wget.{}-{}.{}'.format(plat['platform'], plat['arch'], plat['code']),
            slavenames = [plat['slave']],
            mergeRequests = True,
            factory = m_factory_wget(plat),
            tags = ['c/wget'] + tags))
    c['builders'].append(
        BuilderConfig(name = 'texlive.{}-{}.{}'.format(plat['platform'], plat['arch'], plat['code']),
            slavenames = [plat['slave']],
            mergeRequests = True,
            factory = make_factory_texlive(plat),
            tags = ['c/texlive'] + tags))


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

change_hook_kwargs = {}

c['status'] = [
    WebStatus(
        http_port = config['httpport'],
        authz = util.Authz(
            auth = util.HTPasswdAprAuth(config['htpasswdfile']),
            gracefulShutdown = False,
            forceBuild = 'auth',
            forceAllBuilds = 'auth',
            pingBuilder = 'auth',
            stopBuild = 'auth',
            stopAllBuilds = 'auth',
            cancelPendingBuild = 'auth'),
        **change_hook_kwargs)
    ]


####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title']    = config['title']
c['titleURL'] = config['titleURL']

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = config['titleURL']

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : config['db_url'],
}

