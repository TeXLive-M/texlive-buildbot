# -*- python -*-
# ex: set filetype=python:

import json
import os

from buildbot.plugins import worker, changes, schedulers, steps, util

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

####### HELPER FUNCTIONS #######

def _path(name):
    return os.path.join(os.path.dirname(__file__), name)

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}
# disable statistics submission
c['buildbotNetUsageData'] = None

config = {
    'workersconfig' : _path('workers.json'),
    'htpasswdfile'  : _path('htpasswd'),
    'workerport'    : 9989,
    'httpport'      : 8010,
    'title'         : 'ConTeXt Build Farm',
    'titleURL'      : 'https://build.contextgarden.net/',
    'downloadURL'   : 'http://dl.contextgarden.net/build',
    'downloadPath'  : '/context/www/contextgarden.net/dl/build',
    'db_url'        : 'sqlite:///state.sqlite',
}
####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.

from builder_profiles import builder_profiles, builder_list

with open(config['workersconfig']) as f:
    workerdata = json.load(f)

# list of build workers
c['workers'] = [worker.Worker(w['name'], w['pwd']) for w in workerdata['workers']]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': config['workerport']}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot version of a python hello-world project.

# TeX Live
# - upstream svn
#   - svn://tug.org/texlive/trunk/Build/source
#   - svn://tug.org/texlive/branches/branch20XY/Build/source
# - git mirror
#   - https://github.com/TeX-Live/texlive-source.git
# LuaTeX
# - upstream svn
#   - https://serveur-svn.lri.fr/svn/modhel/luatex
# - git mirror
#   - https://github.com/TeX-Live/luatex
repositories = {
    'texlive': {
        'svn': 'svn://tug.org/texlive/',
        'git': 'https://github.com/TeX-Live/texlive-source.git',
        'branches': ['trunk', 'branches/branch2019'],
        'default_branch': 'trunk',
    },
    'luatex': {
        'svn': 'https://serveur-svn.lri.fr/svn/modhel/luatex',
        'git': 'https://github.com/TeX-Live/luatex.git',
        'branches': ['trunk', 'experimental'],
        'default_branch': 'trunk',
    },
    'luametatex': {
        'rsync': 'rsync://10.100.3.8/luametatexread',
    },
    'pplib': {
        'git': 'https://github.com/contextgarden/pplib.git',
        'branches': ['cmake'],
        'default_branch': 'cmake',
    },
}

# TODO: maybe define a subclass of SVNPoller which redefines split_path?
def split_texlive_branches(path):
    pieces = path.split('/')
    if pieces[0] == 'trunk':
        branch = None
        pieces.pop(0)
    elif pieces[0] == 'branches':
        pieces.pop(0)
        branch = 'branches/{}'.format(pieces.pop(0))
    else:
        return None
    if len(pieces) > 2 and pieces[0] == 'Build' and pieces[1] == 'source':
        return dict(branch = branch, path = '/'.join(pieces[2:]))
    else:
        return None

c['change_source'] = []
c['change_source'].append(
    changes.GitPoller(
        repourl    = repositories['luatex']['git'],
        branches   = repositories['luatex']['branches'],
        category   = 'luatex',
        project    = 'luatex',
        workdir    = 'sources_luatex',
        pollInterval = 300,
    )
)
c['change_source'].append(
    changes.SVNPoller(
        repourl    = repositories['texlive']['svn'],
        split_file = split_texlive_branches,
        category   = 'texlive',
        project    = 'texlive',
        # workdir    = 'sources_texlive',
        pollInterval = 300,
    )
)
c['revlink'] = util.RevlinkMatch([r'svn://tug.org/texlive(.*)'], r'http://tug.org/svn/texlive?view=revision&revision=%s')
c['change_source'].append(
    changes.GitPoller(
        repourl    = repositories['pplib']['git'],
        branches   = repositories['pplib']['branches'],
        category   = 'pplib',
        project    = 'pplib',
        workdir    = 'sources_pplib',
        pollInterval = 300,
    )
)

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

# build_components = ['texlive', 'luatex']
build_components = ['texlive', 'luatex', 'pplib']

builders = {}
builders_all = []
for component in build_components:
    builders[component] = ['{}.{}'.format(component, builder.name) for builder in builder_list]
#    builders[component] = []
#    #branches_allowed[component] = []
#    for builder in builder_list:
#        if builder.profile.platform != 'mingw' or component == 'luatex':
#            builders[component].append('{}.{}'.format(component, builder.name))
    builders_all += builders[component]

for component in ['luametatex']:
    builders[component] = []
    for builder in builder_list:
        if builder.build_luametatex:
            builders[component].append('{}.{}'.format(component, builder.name))
    builders_all += builders[component]

c['schedulers'] = []
for component in build_components:
    c['schedulers'].append(
        schedulers.ForceScheduler(
            name         = 'build-{}'.format(component),
            builderNames = builders[component],
        )
    )
    c['schedulers'].append(
        schedulers.SingleBranchScheduler(
            name = 'commit-{}'.format(component),
            builderNames = builders[component],
            change_filter = util.ChangeFilter(branch = repositories[component]['default_branch']), # default_branch
            treeStableTimer = 60,
        )
    )
for component in ['luametatex']:
    c['schedulers'].append(
        schedulers.Periodic(
            name = 'hourly-{}'.format(component),
            builderNames = builders[component],
            periodicBuildTimer = 6 * 60 * 60,
        )
    )
    c['schedulers'].append(
        schedulers.ForceScheduler(
            name = 'build-{}'.format(component),
            builderNames = builders[component],
        )
    )

####### BUILDERS

class CustomFileUpload(steps.MultipleFileUpload):
    def allUploadsDone(self, result, sources, masterdest):
        if self.url:
            numFiles = len(sources)
            if numFiles:
                self.addURL(self.url, '... {:d} more'.format(numFiles))

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

def make_factory_texlive(builder):
    needs_proxy = (builder.code == 'csw')

    build_env            = builder.env
    build_env['TL_MAKE'] = builder.cmd_make
    build_env['TL_MAKE_FLAGS'] = '-j 2'
    build_command        = ['./Build']
    if builder.platform == 'openbsd':
        build_env['ICU_LIBS_EXTRA'] = '-lpthread'
    # On Solaris we want to avoid dependency on non-standard library iconv
    # On FreeBSD there are two iconv libraries which kind-of-conflict in this setup
    if builder.platform == 'solaris' or builder.platform == 'freebsd':
        build_command.append('--without-iconv')

    f = util.BuildFactory()
    f.addStep(
        steps.SVN(
            repourl         = util.Interpolate("svn{}://tug.org/texlive/%(src::branch:~trunk)s/Build/source".format('+proxy' if needs_proxy else '')),
            extra_args      = ['--config-option=config:miscellany:use-commit-times=yes'],
            method          = 'fresh',
        )
    )
    f.addStep(
        steps.Compile(
            command         = build_command,
            haltOnFailure   = True,
            env             = build_env,
            description     = util.Interpolate("building %(src::branch:~trunk)s"),
            descriptionDone = util.Interpolate("build %(src::branch:~trunk)s"),
        )
    )
    return f



def make_factory_metatex(builder):
    factory_metatex = util.BuildFactory()
    factory_metatex.addStep(
        steps.ShellCommand(
            command = ['rsync', '-av', '--delete', repositories['luametatex']['rsync'], '.'],
            name = 'rsync',
        )
    )
    factory_metatex.addStep(
        steps.CMake(
            path        = 'source',
            definitions = {
                'CMAKE_TOOLCHAIN_FILE': './cmake/freebsd-64.cmake',
            },
        )
    )
    factory_metatex.addStep(
        steps.Compile(
            command       = builder.cmd_make,
            haltOnFailure = True,
            env           = builder.env,
        )
    )
    return factory_metatex

def make_factory_pplib(builder):
    f = util.BuildFactory()
    f.addStep(
        steps.Git(
            repourl = repositories['pplib']['git'],
            branch = repositories['pplib']['default_branch'],
        )
    )
    f.addStep(
        steps.CMake(
            env = builder.env,
            path = '.',
        )
    )
    f.addStep(
        steps.Compile(
            command = builder.cmd_make,
            haltOnFailure = True,
            env = builder.env,
        )
    )
    return f

def make_factory_luatex(builder):
    luatex_build_env     = builder.env
    luatex_build_command = ['./build.sh', '--parallel', '--jit']
    builddir             = 'build'
    exe_suffix           = ''
    filesToUpload = [{
        'srcpath':  'texk/web2c',
        'destpath': 'luatex/{}'.format(builder.tlname),
        'files':    ['luatex{}'.format(exe_suffix), 'luajittex{}'.format(exe_suffix)],
    }]

    factory_luatex      = util.BuildFactory()
    factory_luatex.useProgress = True
    factory_luatex.addStep(
        steps.Git(
            repourl = repositories['luatex']['git'],
            timeout = 3600
        )
    )
    factory_luatex.addStep(
        steps.ShellSequence(
            commands = [
                util.ShellArg(command = ['find', '.', '-name', '*.info', '-exec', 'touch', '{}', '+'], logfile = 'touch info files'),
                util.ShellArg(command = ['touch', './source/texk/web2c/web2c/web2c-lexer.c'], logfile = 'touch web2c-lexer.c'),
                util.ShellArg(command = ['touch', './source/texk/web2c/web2c/web2c-parser.c'], logfile = 'touch web2c-parser.c'),
                util.ShellArg(command = ['touch', './source/texk/web2c/web2c/web2c-parser.h'], logfile = 'touch web2c-parser.h'),
            ],
            description = "touching files",
            descriptionDone = "touched files",
        )
    )
    factory_luatex.addStep(
        steps.Compile(
            command       = luatex_build_command,
            haltOnFailure = True,
            env           = luatex_build_env,
            description     = util.Interpolate("building %(src::branch:~trunk)s"),
            descriptionDone = util.Interpolate("build %(src::branch:~trunk)s")
        )
    )

    # upload it
    if builder.upload and False:
        for f in filesToUpload:
            factory_luatex.addStep(
                CustomFileUpload(
                    workersrcs = f['files'],
                    masterdest = os.path.join(config['downloadPath'], f['destpath']),
                    url        = '{}/{}'.format(config['downloadURL'], f['destpath']),
#                   name            = 'upload_{}'.format(f['srcfile']),
#                   description     = 'upload {}'.format(f['destfile']),
#                   descriptionDone = 'uploaded {}'.format(f['destfile']),
                    keepstamp  = True,
#                   mode       = 0755,
                    doStepIf   = lambda step: step.getProperty('branch') in ['trunk', '', None],
                )
            )

    return factory_luatex

c['builders'] = []
for builder in builder_list:
    tags = ['os/{}'.format(builder.platform)]
    c['builders'].append(
        util.BuilderConfig(
            name = 'texlive.{}'.format(builder.name),
            workernames = [builder.worker],
            factory = make_factory_texlive(builder),
            workerbuilddir = 'texlive', # TODO: what about solaris?
            tags = ['c/texlive'] + tags,
            collapseRequests = True,
            description = 'Build TeX Live',
        )
    )
    c['builders'].append(
        util.BuilderConfig(
            name             = 'luatex.{}'.format(builder.name),
            workernames      = [builder.worker],
            factory          = make_factory_luatex(builder), # TODO: why a function to make the factory?
            # Specifies the name of a subdirectory of the master’s basedir
            # in which everything related to this builder will be stored.
            # builddir       = ... # TODO
            # Specifies the name of a subdirectory (under the worker’s configured base directory)
            # in which everything related to this builder will be placed on the worker.
            workerbuilddir   = 'luatex',
            tags = ['c/luatex'] + tags,
            collapseRequests = True,
            # properties     = ... # TODO
            description = 'Build LuaTeX',
        )
    )
    if builder.build_luametatex:
        c['builders'].append(
            util.BuilderConfig(
                name             = 'luametatex.{}'.format(builder.name),
                workernames      = [builder.worker],
                factory          = make_factory_metatex(builder),
                workerbuilddir   = 'luametatex',
                tags = ['c/luametatex'] + tags,
                collapseRequests = True,
                description = 'Build LuaMetaTeX',
        )
    )
    c['builders'].append(
        util.BuilderConfig(
            name = 'pplib.{}'.format(builder.name),
            workernames = [builder.worker],
            factory = make_factory_pplib(builder),
            workerbuilddir = 'pplib',
            tags = ['c/pplib'] + tags,
            collapseRequests = True,
            description = 'Build pplib',
        )
    )

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

c['services'] = []

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title']    = config['title']
c['titleURL'] = config['titleURL']

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = config['titleURL']

# minimalistic config to activate new web UI
c['www'] = dict(
    port    = config['httpport'],
    plugins = dict(
        waterfall_view = {},
        console_view   = {},
        grid_view = {},
    )
)
# authentication
authz = util.Authz(
    allowRules = [
        util.AnyControlEndpointMatcher(role = 'admins'),
    ],
    roleMatchers = [
        util.RolesFromUsername(
            roles     = ['admins'],
            usernames = [],
        )
    ]
)
c['www']['auth'] = util.HTPasswdAuth(config['htpasswdfile'])
c['www']['authz'] = authz

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : config['db_url'],
}

#print(json.dumps(c['schedulers'], indent = 4))
for s in c['schedulers']:
    print(s.name)

