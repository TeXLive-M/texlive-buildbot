# -*- python -*-
# vim: ft=python:ts=4

import json
import os

#from buildbot.buildslave import BuildSlave
from buildbot.plugins import buildslave, changes, schedulers, status, steps, util
from buildbot.changes import gitpoller, svnpoller
#from buildbot.status.web.baseweb import WebStatus
from buildbot.status.html import WebStatus


####### HELPER FUNCTIONS #######

def _path(name):
    return os.path.join(os.path.dirname(__file__), name)


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

config = {
    'slavesconfig' : _path('slaves.json'),
    'htpasswdfile' : _path('htpasswd'),

    'slaveport'    : 9989,
    'httpport'     : 8010,

    'title'        : 'ConTeXt Build farm',
    'titleURL'     : 'http://build.contextgarden.net',
    'downloadURL'  : 'http://dl.contextgarden.net/build',
    'db_url'       : 'sqlite:///state.sqlite',
}


####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.

from builder_profiles import builder_profiles, builder_list

with open(config['slavesconfig']) as f:
    slavedata = json.load(f)

# list of build slaves
c['slaves'] = [buildslave.BuildSlave(name, pwd) for name, pwd in slavedata['slaves'].iteritems()]

# 'protocols' contains information about protocols which master will use for
# communicating with slaves.
# You must define at least 'port' option that slaves could connect to your master
# with this protocol.
# 'port' must match the value configured into the buildslaves (with their
# --master option)
c['protocols'] = {'pb': {'port': config['slaveport']}}


####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot clone of pyflakes.

luatex_url = 'https://serveur-svn.lri.fr/svn/modhel/luatex'

# TODO: also watch the experimental branch
c['change_source'] = []
c['change_source'].append(svnpoller.SVNPoller(
    svnurl       = 'svn://tug.org/texlive/trunk/Build/source',
    category     = 'texlive',
    project      = 'texlive'))
c['change_source'].append(svnpoller.SVNPoller(
    svnurl       = luatex_url,
    svnuser      = 'anonsvn',
    svnpasswd    = 'anonsvn',
    category     = 'luatex',
    project      = 'luatex',
    split_file   = util.svn.split_file_branches))

from buildbot.plugins import util

c['revlink'] = util.RevlinkMatch([r'svn://tug.org/texlive/(.*)'], 'http://tug.org/svn/texlive?view=revision&revision=%s')

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.changes import filter
from buildbot.plugins import schedulers

build_xz_and_wget = False

build_components = ['texlive', 'luatex']
if build_xz_and_wget:
    build_components.append('wget')
    build_components.append('xz')

builders = {}
builders_all = []
for component in build_components:
    builders[component] = ['{}.{}'.format(component, builder.name) for builder in builder_list]
    builders_all += builders[component]

def luatex_branch_fn(branch):
    return branch in ['trunk', 'experimental']

c['schedulers'] = []
for component in build_components:
    c['schedulers'].append(
        schedulers.ForceScheduler(
            name         = 'build-{}'.format(component),
            builderNames = builders[component]))
c['schedulers'].append(
    schedulers.Nightly(
        name            = 'texlive-nightly',
        branch          = None,
        change_filter   = filter.ChangeFilter(project='texlive'),
        builderNames    = builders['texlive'],
        hour            = 20, # run each day at 20:00
        onlyIfChanged   = True))
c['schedulers'].append(
   schedulers.AnyBranchScheduler(
       name            = 'luatex-trunk',
       change_filter   = util.ChangeFilter(project = 'luatex', branch_fn = luatex_branch_fn),
       # only build once there have been no changes for the last 300 seconds
       treeStableTimer = 300,
       builderNames    = builders['luatex']))

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.source.svn import SVN
from buildbot.steps.shell import ShellCommand
from buildbot.plugins import steps
#from buildbot.plugins.steps import MakeDirectory
from buildbot.steps.shell import Configure
from buildbot.steps.shell import Compile
from buildbot.steps.shell import Test


build_sources = {
    'xz'   : { 'version' : '5.2.3',   'suffix' : '.tar.gz', 'url': 'http://tukaani.org/xz' },
    'wget' : { 'version' : '1.19.1',  'suffix' : '.tar.gz', 'url': 'http://ftpmirror.gnu.org/wget' },
}
for s in build_sources:
    d = build_sources[s]
    name      = '{}-{}'.format(s, d['version'])
    filename  = '{}{}'.format(name, d['suffix'])
    signature = '{}.sig'.format(filename)
    build_sources[s]['name']     = name
    build_sources[s]['file']     = filename
    build_sources[s]['sig']      = signature
    build_sources[s]['file_url'] = '{}/{}'.format(d['url'], filename)
    build_sources[s]['sig_url']  = '{}/{}'.format(d['url'], signature)

# for xz, wget, ...
class SimpleToolFactory(BuildFactory):

    def __init__(self, name, builder, buildSource,
                 configureEnv   = {},
                 configureFlags = [],
                 builddir       = 'build',
                 stripCommand   = None,
                 runTests       = True,
                 filesToUpload  = [],
                ):
        BuildFactory.__init__(self)

        # this is where the sources are
        basedir = 'build'
        # this is where we build the binaries
        workdir = os.path.join(basedir, 'build')

        extractCommand = [builder.cmd_tar]
        buildCommand   = [builder.cmd_make]
        checkCommand   = buildCommand + ['check']

        if buildSource['suffix'] == '.tar.gz':
            extractCommand.append('xvzf')
        elif buildSource['suffix'] == '.tar.bz2':
            extractCommand.append('xvjf')
        elif buildSource['suffix'] == '.tar.bz2':
            extractCommand.append('xvJf')
        extractCommand.append(buildSource['file'])

        configureCommand = [os.path.join('..', buildSource['name'], 'configure')]

        # TODO: this should be a single cleanup step: remove sources + build directory, only leave the downloaded file
        # CLEANUP (TODO)
        #self.addStep(steps.RemoveDirectory(dir=workdir))
        #self.addStep(steps.MakeDirectory(dir=workdir))

        # DOWNLOAD
        self.addStep(ShellCommand(
                name            = 'download',
                command         = ['wget', '-N', '-c', buildSource['file_url']],
                description     = 'fetch sources',
                descriptionDone = 'fetched sources of {}'.format(buildSource['name'])))
        # EXTRACT
        self.addStep(ShellCommand(
                name            = 'extract',
                command         = extractCommand,
                description     = 'extract sources',
                descriptionDone = 'extracted sources'))
        # CONFIGURE
        self.addStep(Configure(
                command         = configureCommand + configureFlags,
                env             = configureEnv,
                logfiles        = {'config.log': 'config.log'},
                workdir         = workdir))
        # BUILD
        self.addStep(Compile(
                command         = buildCommand,
                env             = configureEnv,
                workdir         = workdir))
        # TEST
        if runTests:
            self.addStep(ShellCommand(
                    name            = 'test',
                    command         = checkCommand,
                    env             = configureEnv,
                    logfiles        = {'test-suite.log': 'tests/test-suite.log'},
                    workdir         = workdir,
                    description     = 'test',
                    descriptionDone = 'tested'))
        # STRIP
        if stripCommand != None:
            self.addStep(ShellCommand(
                    name            = 'strip',
                    command         = stripCommand,
                    env             = configureEnv,
                    workdir         = workdir,
                    description     = 'strip binaries',
                    descriptionDone = 'stripped binaries'))
        # UPLOAD
        for f in filesToUpload:
            fileSrc  = os.path.join(builddir, f['srcpath'], f['srcfile'])
            fileDest = os.path.join(f['destpath'], f['destfile'])
            self.addStep(steps.FileUpload(
                slavesrc        = fileSrc,
                masterdest      = os.path.join('/context/www/contextgarden.net/dl/build', fileDest),
                keepstamp       = True,
                mode            = 0644, # TODO?
                url             = '{}/{}'.format(config['downloadURL'], fileDest),
                name            = 'upload_{}'.format(f['srcfile']),
                description     = 'upload {}'.format(f['destfile']),
                descriptionDone = 'uploaded {}'.format(f['destfile']),
            ))

def m_factory_xz(builder):
    configureFlags = [
        '--disable-nls',
        '--disable-shared'
    ]
    configureEnv = builder.env
    if builder.platform == 'solaris':
        configureEnv['GREP'] = 'ggrep'

    stripCommand  = ['strip', 'src/xz/xz', 'src/xzdec/xzdec']

    if builder.upload:
        filesToUpload = [
            { 'srcpath': 'src/xz',    'srcfile': 'xz',    'destpath': 'xz', 'destfile': 'xz.{}'.format(builder.tlname) },
            { 'srcpath': 'src/xzdec', 'srcfile': 'xzdec', 'destpath': 'xz', 'destfile': 'xzdec.{}'.format(builder.tlname) },
        ]
    else:
        filesToUpload = []

    return SimpleToolFactory(
        name           = 'xz',
        builder        = builder,
        buildSource    = build_sources['xz'],
        configureEnv   = configureEnv,
        configureFlags = configureFlags,
        stripCommand   = stripCommand,
        runTests       = True,
        filesToUpload  = filesToUpload,
    )

def m_factory_wget(builder):
    configureFlags = [
        '--enable-ipv6',
        '--disable-iri',
        '--disable-nls',
        '--disable-ntlm',
        '--disable-pcre',
        '--without-libiconv-prefix',
        '--without-libintl-prefix',
        '--without-libuuid',
        '--without-libpsl',
        '--without-ssl',
        '--without-zlib',
    ]
    configureEnv = builder.env
    stripCommand = ['strip', 'src/wget']

    if builder.upload:
        filesToUpload = [{ 'srcpath': 'src', 'srcfile': 'wget', 'destpath': 'wget', 'destfile': 'wget.{}'.format(builder.tlname) }]
    else:
        filesToUpload = []

    return SimpleToolFactory(
        name           = 'wget',
        builder        = builder,
        buildSource    = build_sources['wget'],
        configureEnv   = configureEnv,
        configureFlags = configureFlags,
        stripCommand   = stripCommand,
        runTests       = False,
        filesToUpload  = filesToUpload,
    )

# not used at the moment
class TeXLiveFactory(BuildFactory):
    def __init__(self, source, name, builder, configure='../source/configure',
                 configureEnv    = {},
                 configureFlags  = [],
                 reconf          = None,
                 builddir        = None,
                 make            = 'make',
                 compile_targets = [[]],
                 files           = [],
                 strip           = True
                 # compile       = ['make', 'all'],
                 # test          = ['make', 'check'],
                 # distcheck     = ['make', 'distcheck'],
                 ):
        BuildFactory.__init__(self, [source])

        # determine the build dir
        if builddir is None:
            #builddir = 'build-' + builder.tlname
            builddir = 'build'

        configureEnvLocal   = {}
        configureFlagsLocal = []
        configureEnvLocal['MAKE'] = builder.cmd_make

        self.addStep(steps.RemoveDirectory(dir = os.path.join('build', builddir)))
        self.addStep(steps.MakeDirectory(dir = os.path.join('build', builddir)))

        if reconf is True:
            reconf = ['autoreconf', '-si']
        if reconf is not None:
            self.addStep(ShellCommand(
                name            = 'autoreconf',
                command         = reconf,
                description     = 'running autotools',
                descriptionDone = 'autoreconfigured'))
            # TODO: is tihs a bug somewhere in autoconf?
            #if 'solaris' in platform or 'darwin' in platform:
            #    configureFlagsLocal = ['--disable-dependency-tracking']

        if configure is not None:
            # we either need to wind up with a string (which will be
            # space-split), or with a list of strings (which will not). The
            # list of strings is the preferred form.
            if isinstance(configure, str):
                if configureFlags:
                    assert ' ' not in configure  # please use list instead
                    command = [configure] + configureFlags + configureFlagsLocal
                else:
                    command = configure
            else:
                assert isinstance(configure, (list, tuple))
                command = configure + configureFlags
            self.addStep(Configure(
                command = command,
                env     = configureEnvLocal,
                workdir = 'build/{}'.format(builddir)))
        if compile_targets is not None:
            command = []
            for target in compile_targets:
                command = command + [make] + target + ['&&']
                #command = [make] + target
                #self.addStep(Compile(command = command, workdir = 'build/{}'.format(builddir)))
            #command = ' '.join(command[:-1])
            self.addStep(Compile(
                command = ' '.join(command[:-1]),
                env     = configureEnvLocal,
                workdir = os.path.join('build', builddir)))
        #self.addStep(Test(command = [make, 'test']))
        #if test is not None:
        #    self.addStep(Test(command = test))
        #if distcheck is not None:
        #    self.addStep(Test(command = distcheck))
        if builder.tlname:
            for ff in files:
                fpath = ff[0]
                fname = ff[1]
                file_master = os.path.join(builddir, fpath, fname)
                file_slave  = os.path.join('build', name, builder.tlname, fname)
                if strip is True:
                    self.addStep(ShellCommand(
                        name        = 'strip {}'.format(fname),
                        description = 'strip {}'.format(fname),
                        command     = ['strip', file_master]))
                # TODO: MultipleFileUpload
                # TODO: wrong permissions
                self.addStep(steps.FileUpload(
                    slavesrc    = file_master,
                    masterdest  = '/context/www/contextgarden.net/dl/{}'.format(file_slave),
                    keepstamp   = True,
                    mode        = 0644,
                    url         = 'http://dl.contextgarden.net/{}'.format(file_slave),
                    name        = 'upload {}'.format(fname),
                    description = 'upload {}'.format(fname)))

def make_factory_texlive(builder):
    needs_proxy = (builder.code == 'csw')
    # TODO:
    texlive_url       = 'svn{}://tug.org/texlive/trunk/Build/source'.format('+proxy' if needs_proxy else '')
    factory_texlive   = BuildFactory()

    texlive_build_env            = builder.env
    texlive_build_env['TL_MAKE'] = builder.cmd_make
    #texlive_build_command        = ['./Build', '-C']
    texlive_build_command        = ['./Build']
    # LuaJIT does not compile correctly on OpenBSD for mysterious reasons
    if builder.arch == 'powerpc' or builder.platform == 'openbsd':
        texlive_build_command += ['--disable-luajittex', '--disable-mfluajit']

    if builder.platform == 'openbsd':
        texlive_build_env['ICU_LIBS_EXTRA'] = '-lpthread'
    # On Solaris we want to avoid dependency on non-standard library iconv
    # On FreeBSD there are two iconv libraries which kind-of-conflict in this setup
    if builder.platform == 'solaris' or builder.platform == 'freebsd':
        texlive_build_command.append('--without-iconv')
    if not builder.cxx11:
        texlive_build_command.append('--disable-dvisvgm')

    # check out the source
    factory_texlive.addStep(SVN(
        repourl         = texlive_url,
        extra_args      = ['--config-option=config:miscellany:use-commit-times=yes'],
        method          = 'fresh'))
    # build it
    factory_texlive.addStep(ShellCommand(
        command         = texlive_build_command,
        haltOnFailure   = True,
        env             = texlive_build_env,
        description     = 'building',
        descriptionDone = 'build'))
    # TODO: add some checks like for example
    # ls | while read line; do file $line; done | grep -v symbolic | grep -v shell | cut -f1 -d":" | grep -v '^$' | while read line; do ldd "$line"; done | sort -u
    #
    if builder.upload:
        fileDest = '{}.tar.xz'.format(builder.tlname)
        compressCommand = [builder.cmd_tar, 'cvJf', 'inst.tar.xz', 'bin']

        # compress
        factory_texlive.addStep(ShellCommand(
            name            = 'compress',
            command         = compressCommand,
            haltOnFailure   = True,
            description     = 'compressing',
            descriptionDone = 'compressed',
            workdir         = os.path.join('build', 'inst')))
        # upload
        factory_texlive.addStep(steps.FileUpload(
            slavesrc        = os.path.join('inst', 'inst.tar.xz'),
            masterdest      = os.path.join('/context/www/contextgarden.net/dl/build/texlive', fileDest),
            keepstamp       = True,
            mode            = 0644,
            url             = '{}/{}/{}'.format(config['downloadURL'], 'texlive', fileDest),
            name            = 'upload',
            description     = 'upload {}'.format(fileDest),
            descriptionDone = 'uploaded {}'.format(fileDest)))

    return factory_texlive

# currently used for luatex
def make_factory_luatex(builder):
    luatex_build_env     = builder.env
    luatex_build_command = [ './build.sh' ]
    builddir = 'build'

    build_jit = True
    if builder.arch == 'powerpc' or builder.arch == 'sparc':
        build_jit = False

    filesToUpload = [
        { 'srcpath': 'texk/web2c', 'srcfile': 'luatex', 'destpath': 'luatex/{}'.format(builder.tlname), 'destfile': 'luatex' },
    ]

    if build_jit:
        luatex_build_command.append('--jit')
        filesToUpload.append({ 'srcpath': 'texk/web2c', 'srcfile': 'luajittex', 'destpath': 'luatex/{}'.format(builder.tlname), 'destfile': 'luajittex' })

    factory_luatex      = BuildFactory()
    # check out the source
    factory_luatex.addStep(SVN(
        repourl         = luatex_url,
        username        = 'anonsvn',
        password        = 'anonsvn',
        extra_args      = ['--config-option=config:miscellany:use-commit-times=yes'],
        method          = 'fresh'))
    # build it
    factory_luatex.addStep(ShellCommand(
        command         = luatex_build_command,
        haltOnFailure   = True,
        env             = luatex_build_env,
        description     = 'building',
        descriptionDone = 'build'))
    # upload it
    if builder.upload:
        for f in filesToUpload:
            fileSrc  = os.path.join(builddir, f['srcpath'], f['srcfile'])
            fileDest = os.path.join(f['destpath'], f['destfile'])
            factory_luatex.addStep(steps.FileUpload(
                slavesrc        = fileSrc,
                masterdest      = os.path.join('/context/www/contextgarden.net/dl/build', fileDest),
                keepstamp       = True,
                mode            = 0755,
                name            = 'upload_{}'.format(f['srcfile']),
                description     = 'upload {}'.format(f['destfile']),
                descriptionDone = 'uploaded {}'.format(f['destfile']),
                doStepIf        = lambda step: step.getProperty('branch') == 'trunk',
            ))

    return factory_luatex

from buildbot.config import BuilderConfig

c['builders'] = []

for builder in builder_list:
    tags = ['os/{}'.format(builder.platform)]
    c['builders'].append(
        BuilderConfig(name = 'texlive.{}'.format(builder.name),
            slavenames = [builder.slave],
            mergeRequests = True,
            factory = make_factory_texlive(builder),
            tags = ['c/texlive'] + tags))
    c['builders'].append(
        BuilderConfig(name = 'luatex.{}'.format(builder.name),
            slavenames = [builder.slave],
            mergeRequests = True,
            factory = make_factory_luatex(builder),
            tags = ['c/luatex'] + tags))
    if build_xz_and_wget:
        c['builders'].append(
            BuilderConfig(name = 'xz.{}'.format(builder.name),
                slavenames = [builder.slave],
                mergeRequests = True,
                factory = m_factory_xz(builder),
                tags = ['c/xz'] + tags))
        c['builders'].append(
            BuilderConfig(name = 'wget.{}'.format(builder.name),
                slavenames = [builder.slave],
                mergeRequests = True,
                factory = m_factory_wget(builder),
                tags = ['c/wget'] + tags))


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

change_hook_kwargs = {}

c['status'] = [
    WebStatus(
        http_port = config['httpport'],
        authz = util.Authz(
            auth = util.HTPasswdAprAuth(config['htpasswdfile']),
            gracefulShutdown = False,
            forceBuild = 'auth',
            forceAllBuilds = 'auth',
            pingBuilder = False,
            stopBuild = 'auth',
            stopAllBuilds = 'auth',
            cancelPendingBuild = 'auth'),
        **change_hook_kwargs)
    ]


####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title']    = config['title']
c['titleURL'] = config['titleURL']

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = config['titleURL']

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : config['db_url'],
}
