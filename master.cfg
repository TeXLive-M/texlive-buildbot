# -*- python -*-
# ex: set filetype=python:

import json
import os

from buildbot.plugins import worker, changes, schedulers, steps, util

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

####### HELPER FUNCTIONS #######

def _path(name):
    return os.path.join(os.path.dirname(__file__), name)

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}
# disable statistics submission
c['buildbotNetUsageData'] = None

config = {
    'workersconfig' : _path('workers.json'),
    'htpasswdfile'  : _path('htpasswd'),
    'workerport'    : 9989,
    'httpport'      : 8010,
    'title'         : 'ConTeXt Build Farm',
    'titleURL'      : 'https://build.contextgarden.net/',
    'downloadURL'   : 'http://dl.contextgarden.net/build',
    'downloadPath'  : '/context/www/contextgarden.net/dl/build',
    'db_url'        : 'sqlite:///state.sqlite',
}
####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.

from builder_profiles import builder_profiles, builder_list

with open(config['workersconfig']) as f:
    workerdata = json.load(f)

# list of build workers
c['workers'] = [worker.Worker(w['name'], w['pwd']) for w in workerdata['workers']]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': config['workerport']}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot version of a python hello-world project.

# TeX Live
# - upstream svn
#   - svn://tug.org/texlive/trunk/Build/source
#   - svn://tug.org/texlive/branches/branch20XY/Build/source
# - git mirror
#   - https://github.com/TeX-Live/texlive-source.git
# LuaTeX
# - upstream svn
#   - https://serveur-svn.lri.fr/svn/modhel/luatex
# - git mirror
#   - https://github.com/TeX-Live/luatex
repositories = {
    'texlive': {
        'svn': 'svn://tug.org/texlive/',
        'git': 'https://github.com/TeX-Live/texlive-source.git',
        'branches': ['trunk', 'branches/branch2019'],
        'default_branch': 'trunk',
    },
    'luatex': {
        'svn': 'https://serveur-svn.lri.fr/svn/modhel/luatex',
        'git': 'https://github.com/TeX-Live/luatex.git',
        'branches': ['trunk', 'experimental'],
        'default_branch': 'trunk',
    },
    'luametatex': {
        'git': 'file:///context/mirror/git/luametatex.git',
        'branches': ['master'],
        'rsync': 'rsync://10.100.3.8/luametatexread',
    },
    'pplib': {
        'git': 'https://github.com/contextgarden/pplib.git',
        'branches': ['master'],
        'default_branch': 'master',
    },
}

# TODO: maybe define a subclass of SVNPoller which redefines split_path?
def split_texlive_branches(path):
    pieces = path.split('/')
    if pieces[0] == 'trunk':
        branch = None
        pieces.pop(0)
    elif pieces[0] == 'branches':
        pieces.pop(0)
        branch = 'branches/{}'.format(pieces.pop(0))
    else:
        return None
    if len(pieces) > 2 and pieces[0] == 'Build' and pieces[1] == 'source':
        return dict(branch = branch, path = '/'.join(pieces[2:]))
    else:
        return None

c['change_source'] = []
c['change_source'].append(
    changes.GitPoller(
        repourl    = repositories['luatex']['git'],
        branches   = repositories['luatex']['branches'],
        category   = 'luatex',
        project    = 'luatex',
        workdir    = 'sources_luatex',
        pollInterval = 300,
    )
)
c['change_source'].append(
    changes.SVNPoller(
        repourl      = repositories['texlive']['svn'],
        split_file   = split_texlive_branches,
        category     = 'texlive',
        project      = 'texlive',
        pollInterval = 300,
    )
)
c['change_source'].append(
    changes.GitPoller(
        repourl    = repositories['pplib']['git'],
        branches   = repositories['pplib']['branches'],
        category   = 'pplib',
        project    = 'pplib',
        workdir    = 'sources_pplib',
        pollInterval = 300,
    )
)
c['change_source'].append(
    changes.GitPoller(
        repourl  = repositories['luametatex']['git'],
        branches = repositories['luametatex']['branches'],
        category = 'luametatex',
        project  = 'luametatex',
        workdir  = 'sources_luametatex',
        pollInterval = 300,
        pollAtLaunch = True,
    )
)

c['revlink'] = util.RevlinkMatch(
    [r'svn://tug.org/texlive(.*)'],
    r'http://tug.org/svn/texlive?view=revision&revision=%s'
)

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

build_components = ['texlive', 'luatex', 'pplib', 'luametatex']

builders = {}
builders_all = []
for component in build_components:
    builders[component] = []
    for builder in builder_list:
        if builder.build[component]:
            builders[component].append('{}.{}'.format(component, builder.name))
    builders_all += builders[component]

c['schedulers'] = []
for component in build_components:
    c['schedulers'].append(
        schedulers.ForceScheduler(
            name         = 'build-{}'.format(component),
            builderNames = builders[component],
        )
    )
    c['schedulers'].append(
        schedulers.SingleBranchScheduler(
            name            = 'commit-{}'.format(component),
            change_filter   = util.ChangeFilter(project = component),
            builderNames    = builders[component],
            #change_filter   = util.ChangeFilter(branch = repositories[component]['default_branch']),
            treeStableTimer = 300,
        )
    )
    print('Adding SingleBranchScheduler for {}. The scheduler should trigger {} components:'.format(component, len(builders[component])))
    for builder in builders[component]:
        print('- builder: {}'.format(builder))

####### BUILDERS

class CustomFileUpload(steps.MultipleFileUpload):
    def allUploadsDone(self, result, sources, masterdest):
        if self.url:
            numFiles = len(sources)
            if numFiles:
                self.addURL(self.url, '... {:d} more'.format(numFiles))

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

def make_factory_texlive(builder):
    needs_proxy = (builder.code == 'csw')

    build_env                  = builder.env
    build_env['TL_MAKE']       = builder.cmd_make
    build_command              = ['./Build']
    if builder.platform == 'openbsd':
        build_env['ICU_LIBS_EXTRA'] = '-lpthread'
    # On Solaris we want to avoid dependency on non-standard library iconv
    # On FreeBSD there are two iconv libraries which kind-of-conflict in this setup
    if builder.platform == 'solaris' or builder.platform == 'freebsd':
        build_command.append('--without-iconv')

    f = util.BuildFactory()
    f.addStep(
        steps.SVN(
            repourl         = util.Interpolate("svn{}://tug.org/texlive/%(src::branch:~trunk)s/Build/source".format('+proxy' if needs_proxy else '')),
            extra_args      = ['--config-option=config:miscellany:use-commit-times=yes'],
            method          = 'fresh',
        )
    )
    f.addStep(
        steps.Compile(
            command         = build_command,
            haltOnFailure   = True,
            env             = {**build_env, 'TL_MAKE_FLAGS': 'check_target=skip -j 2'},
            logfiles        = {'build info': './Work/buildinfo.log', 'build environment': './Work/buildenv.log'},
            lazylogfiles    = True,
            description     = util.Interpolate("building %(src::branch:~trunk)s"),
            descriptionDone = util.Interpolate("build %(src::branch:~trunk)s"),
        )
    )
    f.addStep(
        steps.Compile(
            name            = 'test',
            command         = ['./Build', '--no-clean'],
            haltOnFailure   = False,
            flunkOnFailure  = False,
            warnOnFailure   = True,
            env             = {**build_env, 'TL_TARGET': 'check', 'TL_CONFIGURE': 'true'},
            description     = 'testing',
            descriptionDone = 'test',
        )
    )
    if builder.upload:
        fileDest = '{}.tar.xz'.format(builder.tlname)
        f.addStep(
            steps.ShellCommand(
                name          = 'compress',
                #command = ['mv', 'inst/bin/*', 'inst/bin/{}'.format(builder.tlname)]),
                command       = [builder.cmd_tar, 'cvJf', 'inst.tar.xz', 'bin'],
                haltOnFailure = True,
                description   = 'compressing',
                workdir       = os.path.join('build', 'inst'),
            )
        )
        f.addStep(
            steps.FileUpload(
                workersrc  = os.path.join('inst', 'inst.tar.xz'),
                masterdest = os.path.join(config['downloadPath'], 'texlive', fileDest),
                mode       = 0o644,
                url        = '{}/{}/{}'.format(config['downloadURL'], 'texlive', fileDest),
            )
        )

    return f



def make_factory_metatex(builder):
    f = util.BuildFactory()
    binary_filename = 'luametatex'
    if builder.platform == 'openbsd':
        toolchain_file = './cmake/openbsd-64.cmake'
    elif builder.platform == 'mingw':
        binary_filename = 'luametatex.exe'
        if builder.arch == 'i386':
            toolchain_file = './cmake/mingw-32.cmake'
        else:
            toolchain_file = './cmake/mingw-64.cmake'
    else:
        toolchain_file = './cmake/linux-64.cmake'

    f.addStep(
        steps.ShellCommand(
            command = ['rsync', '-av', '--delete', repositories['luametatex']['rsync'], '.'],
            name    = 'rsync',
        )
    )
    f.addStep(
        steps.CMake(
            path        = 'source',
            definitions = {
                'CMAKE_TOOLCHAIN_FILE': toolchain_file,
            },
        )
    )
    f.addStep(
        steps.Compile(
            command        = builder.cmd_make,
            haltOnFailure  = True,
            warnOnWarnings = True,
            env            = builder.env,
        )
    )
    if builder.upload or True:
        f.addStep(
            steps.FileUpload(
                workersrc  = binary_filename,
                masterdest = os.path.join(config['downloadPath'], 'luametatex', builder.tlname, binary_filename),
                url        = '{}/{}/{}'.format(config['downloadURL'], 'luametatex', builder.tlname),
                mode       = 0o755,
            )
        )
    return f

def make_factory_pplib(builder):
    build_env = builder.env

    f = util.BuildFactory()
    f.addStep(
        steps.Git(
            repourl    = repositories['pplib']['git'],
            branch     = repositories['pplib']['default_branch'],
            submodules = True,
        )
    )
    f.addStep(
        steps.CMake(
            path = '.',
            env  = builder.env,
        )
    )
    f.addStep(
        steps.Compile(
            command        = builder.cmd_make,
            haltOnFailure  = True,
            warnOnWarnings = True,
            env            = builder.env,
        )
    )
    return f

def make_factory_luatex(builder):
    luatex_build_env     = builder.env
    luatex_build_command = ['./build.sh', '--parallel', '--jit']
    builddir             = 'build'
    exe_suffix           = ''
    filesToUpload = [{
        'srcpath':  'texk/web2c',
        'destpath': 'luatex/{}'.format(builder.tlname),
        'files':    ['luatex{}'.format(exe_suffix), 'luajittex{}'.format(exe_suffix)],
    }]

    f = util.BuildFactory()
    f.useProgress = True
    f.addStep(
        steps.Git(
            repourl = repositories['luatex']['git'],
            timeout = 3600
        )
    )
    f.addStep(
        steps.ShellSequence(
            commands = [
                util.ShellArg(command = ['find', '.', '-name', '*.info', '-exec', 'touch', '{}', '+'], logfile = 'touch info files'),
                util.ShellArg(command = ['touch', './source/texk/web2c/web2c/web2c-lexer.c'], logfile = 'touch web2c-lexer.c'),
                util.ShellArg(command = ['touch', './source/texk/web2c/web2c/web2c-parser.c'], logfile = 'touch web2c-parser.c'),
                util.ShellArg(command = ['touch', './source/texk/web2c/web2c/web2c-parser.h'], logfile = 'touch web2c-parser.h'),
            ],
            description     = "touching files",
            descriptionDone = "touched files",
        )
    )
    f.addStep(
        steps.Compile(
            command         = luatex_build_command,
            haltOnFailure   = True,
            env             = luatex_build_env,
            description     = util.Interpolate("building %(src::branch:~trunk)s"),
            descriptionDone = util.Interpolate("build %(src::branch:~trunk)s")
        )
    )

    # upload it
    if builder.upload and False:
        for f in filesToUpload:
            f.addStep(
                CustomFileUpload(
                    workersrcs = f['files'],
                    masterdest = os.path.join(config['downloadPath'], f['destpath']),
                    url        = '{}/{}'.format(config['downloadURL'], f['destpath']),
#                   name            = 'upload_{}'.format(f['srcfile']),
#                   description     = 'upload {}'.format(f['destfile']),
#                   descriptionDone = 'uploaded {}'.format(f['destfile']),
                    keepstamp  = True,
#                   mode       = 0755,
                    doStepIf   = lambda step: step.getProperty('branch') in ['trunk', '', None],
                )
            )

    return f

c['builders'] = []
for builder in builder_list:
    tags = ['os.{}'.format(builder.platform)]
    if builder.build['texlive']:
        c['builders'].append(
            util.BuilderConfig(
                name             = 'texlive.{}'.format(builder.name),
                workernames      = [builder.worker],
                factory          = make_factory_texlive(builder),
                workerbuilddir   = 'texlive/{}'.format(builder.name),
                tags             = ['c.texlive'] + tags,
                collapseRequests = True,
                description      = 'Build TeX Live',
            )
        )
    if builder.build['luatex']:
        c['builders'].append(
            util.BuilderConfig(
                name             = 'luatex.{}'.format(builder.name),
                workernames      = [builder.worker],
                factory          = make_factory_luatex(builder), # TODO: why a function to make the factory?
                # Specifies the name of a subdirectory of the master’s basedir
                # in which everything related to this builder will be stored.
                # builddir       = ... # TODO
                # Specifies the name of a subdirectory (under the worker’s configured base directory)
                # in which everything related to this builder will be placed on the worker.
                workerbuilddir   = 'luatex/{}'.format(builder.name),
                tags             = ['c.luatex'] + tags,
                collapseRequests = True,
                # properties     = ... # TODO
                description      = 'Build LuaTeX',
            )
        )
    if builder.build['luametatex']:
        c['builders'].append(
            util.BuilderConfig(
                name             = 'luametatex.{}'.format(builder.name),
                workernames      = [builder.worker],
                factory          = make_factory_metatex(builder),
                workerbuilddir   = 'luametatex/{}'.format(builder.name),
                tags             = ['c.luametatex'] + tags,
                collapseRequests = True,
                description      = 'Build LuaMetaTeX',
        )
    )
    if builder.build['pplib']:
        c['builders'].append(
            util.BuilderConfig(
                name             = 'pplib.{}'.format(builder.name),
                workernames      = [builder.worker],
                factory          = make_factory_pplib(builder),
                workerbuilddir   = 'pplib/{}'.format(builder.name),
                tags             = ['c.pplib'] + tags,
                collapseRequests = True,
                description      = 'Build pplib',
            )
        )

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

c['services'] = []

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title']    = config['title']
c['titleURL'] = config['titleURL']

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = config['titleURL']

# minimalistic config to activate new web UI
c['www'] = dict(
    port    = config['httpport'],
    plugins = dict(
        waterfall_view = {},
        console_view   = {},
        grid_view      = {},
    )
)
c['www']['ui_default_config'] = {
    #'Waterfall.scaling_waterfall': 0.3,
    'Waterfall.show_builders_without_builds': True,
}

# authentication
authz = util.Authz(
    allowRules = [
        util.AnyControlEndpointMatcher(role = 'admins'),
    ],
    roleMatchers = [
        util.RolesFromUsername(
            roles     = ['admins'],
            usernames = [],
        )
    ]
)
c['www']['auth']  = util.HTPasswdAuth(config['htpasswdfile'])
c['www']['authz'] = authz

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url': config['db_url'],
}
